#20190712

setwd("C:/Users/User/Desktop/BigDataCampus-master")
getwd()
Titanic=read.csv("train.csv",sep=",",header=T,strip.white = T)
Titanic

sum(is.na(Titanic))
#----------------------------------------------------


autoparts=read.csv("autoparts.csv",header=TRUE)

# prod_no에 해당되는 값들을 가져오는데 첫번째 열은 제외한다. 

autoparts3=autoparts[autoparts$prod_no=="45231-3B610",-1]
autoparts3

#해당 column만 boxplot형태로 보여준다. 
# 계략적인 데이터 분포를 알려준다.
boxplot(autoparts3$c_thickness)
#boxplot(autoparts3)

data=autoparts3$c_thickness
data
#fivenum(data[2])는 1사분위수를 나타낸다.
#which는 행번호를 알려준다. 
which(data<fivenum(data[2])-1.5*IQR(data))
which(data>fivenum(data[4])+1.5*IQR(data))
?which

# data=0:100
# quantile(data)
# IQR(data)
# fivenum(data)

# 회귀모형을 구한다. 
# c_thickness를 종속변수로 하고, ~. 는 나머지 모든 column들을 독립변수로한다. 
# data는 autoparts3로 한다. 
m=lm(c_thickness~.,data=autoparts3)

# 잔차를 구한다.
# 잔차가 클 수록 이상치일 가능성이 크다. 
rstudent(m)

plot(rstudent(m),main="Studentized Residuals")

install.packages("car")
library(car)
outlierTest(m)
#통계적으로 유의미하게 잔차가 큰 값이다.(bonferonni p<0.05)
#Bonferonni p는 수정된 값으로 독립변수(가설)가 많아질수록 올바른 귀무가설이
#기각될 확률 a(알파)가 커지는 현상을 보정한 값이다. 
#따라서 bonferonni p는 원래 p-value보다 커짐
#(귀무가설 채택 확률이 늘어나고, 연구가설 채택 확률은 줄어든다.)

m=lm(c_thickness~.,data=autoparts3)
plot(m)
#왼쪽에서 멀어질수록, 중앙에서 떨어질수록 쿡의 거리는 높게 나타난다. 


cooks=cooks.distance(m)
plot(cooks,pch=".",cex=1.5,main="Plot for Cook's Distance")
text(x=1:length(cooks),y=cooks,labels=ifelse(cooks>4/nrow(autoparts3),names(cooks),""),col="red")


influential=names(cooks)[(cooks>4/nrow(autoparts3))]
influential
#해당 데이터만 보이기
autoparts3[rownames(autoparts3)%in%influential,]

install.packages("outliers")
library(outliers)
outlier(autoparts3$c_thickness)
outlier(autoparts3$c_thickness,opposite=TRUE)


#------------------------------------------------------
install.packages("DMwR")
library(DMwR)

#K=5는 주위를 몇개를 참고할 것인가?
score=lofactor(autoparts3,k=5)
#class(score)   #numeric
#str(score)     #num
plot(score)
top5=order(score,decreasing=TRUE)[1:5]; top5
#order은 정렬하는 함수이다. decreasing=True 는 내림차순 [1:5] 1위부터 5위까지 


Titanic
boxplot(Titanic)
# 이상치로 추정되는 column은 fare,cabin

score=Titanic$Fare
plot(score,pch=".",cex=1.5,main="Plot for Cook's Distance")
text(x=1:length(cooks),labels=ifelse(cooks>4/nrow(score),names(cooks),""),col="red")
top5=order(score,decreasing = TRUE)[1:5]
top5


#-------------------apply 매우 중요-----------

# matrix를 만든다.
# 1~9까지의 값이 원소로 들어가며
# column의 개수는 3개이다. 

m=matrix(1:9,ncol=3);m
apply(x,1,func)

say=function(s){
  print("당신이 입력한 문장은 아래와 같습니다.")
  print(s)
}

say("Hello World")
say("안녕하세요")

final.score=function(name,current.score){
  print(name)
  print(paste("your final score:",current.score+2))
}

final.score("조현정",91)
final.score("김동길",88)

a=3
if(a==3){
  print("3입니다.")
}
else{
  print(a)
}

a=2
if(a==3){
  print("3입니다.")
}else if(a==2){
  print("2입니다.")
}else{
  print(a)
}


for(i in 1:10){
  print(i)
}

x=1:10
for(i in x){
  print(i)
}

x=c(1:10)
for(i in 1:length(x)){
  print(i)
}

my.func1=function(m){
  m+1
  if(m==NA){
    m=1
  }
}

m=matrix(1:9,ncol=3); m

# 열방향으로 함수를 적용시켜 출력한다. 
apply(m,2,my.func1)
#apply(m,1,my.func1) 이면 행으로 함수를 실행시키고, 열방향으로 출력한다. 
# 출력 결과값을 다르게 보이는걸 인지한다. 

my.func2=function(m,var){
  m+var
  if(NA)
    m=1
}

m=matrix(1:9,ncol=3); m
apply(m,2,my.func2,3)
apply(m,1,my.func2,3)
?apply

x=c(1,2,3,4,NA)
y=c(1,2,3,4,NA)
z=c(2,3,4,5,NA)
DATA=data.frame(x,y,z)
DATA

apply(DATA,2,my.func1)


sum(1:10)
sum(1,2,3,4,5)
x=c(3,5,19,21,33)
sum(x)
mean(x)

m=matrix(1:9,ncol=3);m
m1=apply(m,2,sum)
m2=apply(m,1,sum)

head(iris)
apply(iris[,1:4],2,sum)
dim(iris)

#dim 함수는 몇행 몇열인지 알려준다. ex) 2x2, 150x5

colSums(iris[,1:4])
rowSums(iris[,1:4])

#colSums는 열의 합을 알려준다.


#lapply는 리스트를 입력데이터로 받아요! 
l=lapply(iris[,1:4],mean);l
v=unlist(l)
m=matrix(v,ncol=4)
m
#num.list=list(num1=c(10,20),num2=c(30,40,50));num.list
num.list=list(num1=c(10,20),m);num.list
lapply(num.list,sqrt)
lapply(num.list,sum)

l=lapply(iris[,1:4],mean);l
v=unlist(l)
v

m=matrix(v,ncol=4);m
d=as.data.frame(m);d

#원 데이터프레임의 이름으로 결과에 이름 부여
names(d)=names(iris[,1:4]);d

l=lapply(iris[,1:4], mean);l
v=unlist(l); v
class(v)


lapply(iris[,1:2],sqrt)

#--------------------------------------
str(iris)
class(iris)

#lapply는 열을 기준으로 적용시킨다. 
lapply(iris[,1:2],sqrt)
lapply(iris[,1:2],sum)
colSums(iris[,1:2])



m=matrix(1:9,ncol=3)
df=as.data.frame(m)
my.func1=function(m){
  m+1
}
my.func2=function(m,var){
  m+var
}
my.func3=function(m,var1,var2){
  m+var1+var2
}
lapply(m,my.func1)
lapply(m,my.func2,3)
lapply(m,my.func3,1,2)

lapply(df,my.func1)


x=1:3
sapply(x,sqrt)

sapply(iris[,1:2],sum)

v=sapply(iris[,1:4],mean);v
d=as.data.frame(v);d
d=t(d)
d

m=sapply(iris[,1:2],sqrt)
m
class(m)
df=as.data.frame(m);df 

# tapply는 입력데이터,기준컬럼,데이터에 적용할 함수로 구성
# 기준컬럼별로 함수를 적용시킨다. 
id=c(1,2,3)
gender=c("F","F","M")
height=c(160,165,170)
df=data.frame(id,gender,height);df

tapply(df$height,df$gender,sum)
tapply(df$height,df$gender,sqrt)

#----------------------연습-----------------------------

mtcars
str(mtcars)
apply(mtcars,2,mean)

apply(mtcars["Merc 240D",1:11],1,mean)

colSums(mtcars)
colMeans(mtcars["Merc 240D",1:11])




data=lapply(mtcars,sum)
data=unlist(data)
class(data)

sapply(mtcars,sum)

tapply(mtcars$vs==0,mtcars$vs==1,mean)
tapply(mtcars$hp,mtcars$gear,mean)











